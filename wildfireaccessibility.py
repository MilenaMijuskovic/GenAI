# -*- coding: utf-8 -*-
"""WildfireAccessibility.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cbPA6laxQBM5cexPWxf4NjYfI6S1vf08
"""

!pip install googlemaps

import googlemaps
import folium
from googlemaps.convert import decode_polyline

#... get_route and create_map functions from above.

def main():
    origin = input("Enter origin address or coordinates: ")
    destination = input("Enter destination address or coordinates: ")
    api_key = input("Enter your Google Maps API key: ")

    route_coordinates = get_route(origin, destination, api_key)
    create_map(route_coordinates)

if __name__ == "__main__":
    main()

import requests
import json
import googlemaps
import folium
from googlemaps.convert import decode_polyline  # Import correct decoding function

def get_coordinates():
    try:
        origin_str = input()
        origin = eval(origin_str)
        destination_str = input()
        destination = eval(destination_str)

        if not (isinstance(origin, list) and len(origin) == 2 and
                isinstance(destination, list) and len(destination) == 2):
            raise ValueError("Invalid coordinate format. Must be [latitude, longitude].")

        return origin, destination

    except (ValueError, SyntaxError, NameError) as e:
        print(f"Error: {e}")
        return None, None

origin, destination = get_coordinates()

if origin and destination:
    #print(f"Origin: {origin}, Destination: {destination}")

    api_key = "AIzaSyDOasWCFyUrISMIqyy8w5jpPNgyUhk3yvM"
    url = f"https://routes.googleapis.com/directions/v2:computeRoutes?key={api_key}"

    headers = {
        "Content-Type": "application/json",
        "X-Goog-FieldMask": "routes.distanceMeters,routes.duration,routes.polyline.encodedPolyline"
    }

    payload = {
        "origin": {
            "location": {
                "latLng": {
                    "latitude": origin[0],
                    "longitude": origin[1]
                }
            }
        },
        "destination": {
            "location": {
                "latLng": {
                    "latitude": destination[0],
                    "longitude": destination[1]
                }
            }
        },
        "travelMode": "DRIVE",
        "routingPreference": "TRAFFIC_AWARE"
    }

    response = requests.post(url, headers=headers, json=payload)

    if response.status_code == 200:
        data = response.json()
        print(json.dumps(data, indent=2))  # Nicely formatted JSON

        # Initialize Google Maps client (replace with your API key)
        gmaps = googlemaps.Client(key="AIzaSyDOasWCFyUrISMIqyy8w5jpPNgyUhk3yvM")

        # Decode the polyline
        from googlemaps.convert import decode_polyline

        decoded_path = decode_polyline(data["routes"][0]["polyline"]["encodedPolyline"])

        # Extract coordinates
        coordinates = [(coord["lat"], coord["lng"]) for coord in decoded_path]

        # Create a Folium map centered on the first coordinate
        map_center = coordinates[0]
        m = folium.Map(location=map_center, zoom_start=12)

        # Add the polyline to the map
        folium.PolyLine(locations=coordinates, color="blue").add_to(m)

        # Display the map
        m.save("route_map.html") #saves the map to a html file that can be opened in a browser.

else:
    print(f"Error: {response.status_code}")
    print(response.text)

import networkx as nx
import matplotlib.pyplot as plt

# 1. Simplified Wildfire Data
# Example road network (nodes and edges)
edges = [
    ("A", "B", {"distance": 10, "fire_distance": 5}),  # (node1, node2, {attributes})
    ("B", "C", {"distance": 15, "fire_distance": 10}),
    ("C", "D", {"distance": 5, "fire_distance": 2}),
    ("A", "D", {"distance": 20, "fire_distance": 8}),
    ("B", "D", {"distance": 7, "fire_distance": 15}),
]

fire_perimeter_nodes = ["C"]  # Nodes within or close to the fire perimeter

# 2. Network Graph
G = nx.Graph()
G.add_edges_from([(u, v, data) for u, v, data in edges])

# 3. Cost Function (Distance + Fire Proximity)
def cost_function(u, v, data):
    distance_weight = 1.0  # Adjust these weights to change the importance of these parameters.
    fire_distance_weight = 2.0
    return data["distance"] * distance_weight + (20 - data["fire_distance"]) * fire_distance_weight # 20 is just a number to make the fire distance a higher cost when closer.

# 4. Shortest Path Calculation (using custom cost function)
start_node = "A"
end_node = "D"
shortest_path = nx.shortest_path(G, source=start_node, target=end_node, weight=cost_function)

# 5. Visualization
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True)
edge_labels = nx.get_edge_attributes(G, "distance")
nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)
nx.draw_networkx_nodes(G, pos, nodelist=fire_perimeter_nodes, node_color="red")
nx.draw_networkx_nodes(G, pos, nodelist=shortest_path, node_color="green")

plt.show()










import networkx as nx
import matplotlib.pyplot as plt
import random  # For simulating accessibility data

# --- 1. Road Network and Wildfire Data ---
edges = [
    ("A", "B", {"distance": 10, "fire_distance": 5}),
    ("B", "C", {"distance": 15, "fire_distance": 10}),
    ("C", "D", {"distance": 5, "fire_distance": 2}),
    ("A", "D", {"distance": 20, "fire_distance": 8}),
    ("B", "D", {"distance": 7, "fire_distance": 15}),
]

fire_perimeter_nodes = ["C"]

# --- 2. Simulated Accessibility Data ---
# Assume each edge has an accessibility score (0: inaccessible, 1: fully accessible)
accessibility_data = {
    ("A", "B"): 0.8,  # 80% accessible
    ("B", "C"): 0.2,  # 20% accessible (e.g., stairs)
    ("C", "D"): 0.9,  # 90% accessible
    ("A", "D"): 0.7,  # 70% accessible
    ("B", "D"): 0.6,  # 60% accessible
}

# --- 3. Network Graph ---
G = nx.Graph()
G.add_edges_from([(u, v, data) for u, v, data in edges])

# --- 4. Enhanced Cost Function ---
def cost_function(u, v, data):
    distance_weight = 1.0  # Weight for distance
    fire_distance_weight = 2.0  # Weight for fire proximity
    accessibility_weight = 3.0  # Weight for accessibility

    # Fire proximity cost (higher cost when closer to fire)
    fire_cost = (20 - data["fire_distance"]) * fire_distance_weight

    # Accessibility cost (higher cost for less accessible routes)
    accessibility_cost = (1 - accessibility_data.get((u, v), 0.5)) * accessibility_weight

    # Total cost
    total_cost = (
        data["distance"] * distance_weight +
        fire_cost +
        accessibility_cost
    )
    return total_cost

# --- 5. Shortest Path Calculation ---
start_node = "A"
end_node = "D"
shortest_path = nx.shortest_path(G, source=start_node, target=end_node, weight=lambda u, v, d: cost_function(u, v, d))

# --- 6. Visualization ---
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, node_size=700, node_color="skyblue", font_size=10, font_weight="bold")
edge_labels = nx.get_edge_attributes(G, "distance")
nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color="red")

# Highlight fire perimeter nodes
nx.draw_networkx_nodes(G, pos, nodelist=fire_perimeter_nodes, node_color="red", node_size=800)

# Highlight shortest path nodes
path_edges = list(zip(shortest_path, shortest_path[1:]))
nx.draw_networkx_edges(G, pos, edgelist=path_edges, edge_color="green", width=2)
nx.draw_networkx_nodes(G, pos, nodelist=shortest_path, node_color="green", node_size=800)

plt.title("Accessible Escape Route During Wildfire")
plt.show()

import csv
import googlemaps

def get_closest_shelters(lat, lng, radius=50000, max_shelters=25):
    gmaps = googlemaps.Client(key='AIzaSyDOasWCFyUrISMIqyy8w5jpPNgyUhk3yvM')

    # Search for nearby shelters
    places_result = gmaps.places_nearby(
        location=(lat, lng),
        radius=radius,
        keyword="emergency shelter"
    )

    shelters = places_result.get("results", [])

    return [
        {
            "name": shelter["name"],
            "address": shelter.get("vicinity", "N/A"),
            "location": shelter["geometry"]["location"]
        }
        for shelter in shelters
    ]

def get_accessible_shelters(lat, lng, radius=50000, max_shelters=25):
    gmaps = googlemaps.Client(key='AIzaSyDOasWCFyUrISMIqyy8w5jpPNgyUhk3yvM')


    accessible_words = {'access', 'ramp', 'wheelchair', 'elevator', 'accessible', 'disability', 'disabled', 'handicap', 'handicapped', 'mobility', 'impairment', 'impairments', 'disabilities', 'disability'}
    non_accessible_words = {'no access', 'stairs', 'no elevator', 'no ramp', 'icy', 'steep', 'obstacles', 'no wheelchair'}

    # Search for nearby shelters
    places_result = gmaps.places_nearby(
        location=(lat, lng),
        radius=radius,
        keyword="emergency shelter"
    )

    shelters = places_result.get("results", [])
    accessible_shelters = []

    for shelter in shelters:
        place_details = gmaps.place(
            place_id=shelter["place_id"],
            fields=["name", "vicinity", "geometry", "wheelchair_accessible_entrance"]
        )
        wheelchair_accessible = place_details.get("result", {}).get("wheelchair_accessible_entrance", False)

        if wheelchair_accessible:
            accessible_shelters.append(shelter)

    return [
        {
            "name": shelter["name"],
            "address": shelter.get("vicinity", "N/A"),
            "location": shelter["geometry"]["location"]
        }
        for shelter in accessible_shelters
    ]

def save_shelters_to_csv(shelters, filename="shelters.csv"):
    with open(filename, mode="w", newline="", encoding="utf-8") as file:
        writer = csv.DictWriter(file, fieldnames=["name", "address", "location"])
        writer.writeheader()
        writer.writerows(shelters)

if __name__ == "__main__":
    current_lat = 40.7128  # Example latitude (New York City)
    current_long = -74.0060  # Example longitude (New York City)

    closest_shelters = get_closest_shelters(current_lat, current_long)
    closest_accessible_shelters = get_accessible_shelters(current_lat, current_long)

    save_shelters_to_csv(closest_shelters)
    save_shelters_to_csv(closest_accessible_shelters, filename="shelters.csv")

import csv

# Open and read CSV file
with open("shelters.csv", mode="r", newline="") as file:
    reader = csv.reader(file)
    next(reader)
    for row in reader:
        print(row)  # Each row is a list

import folium

# Create map
m = folium.Map(location=[latitude, longitude], zoom_start=10)

# Add evacuation sites to map
for place in data["results"]:
    folium.Marker(
        location=[place["geometry"]["location"]["lat"], place["geometry"]["location"]["lng"]],
        popup=place["name"],
        icon=folium.Icon(color="green"),
    ).add_to(m)

# Save map
m.save("evacuation_map.html")

pip install ucimlrepo

from ucimlrepo import fetch_ucirepo

# fetch dataset
forest_fires = fetch_ucirepo(id=162)

# data (as pandas dataframes)
X = forest_fires.data.features
y = forest_fires.data.targets

# metadata
print(forest_fires.metadata)

# variable information
print(forest_fires.variables)

import tensorflow as tf
from tensorflow.keras.layers import Input, Dense, LSTM, Conv2D, Flatten, Concatenate
from tensorflow.keras.models import Model

# Input 1: Numerical data (weather, fire index)
num_input = Input(shape=(10,))  # Adjust based on your features
x = Dense(64, activation="relu")(num_input)
x = Dense(32, activation="relu")(x)
num_output = Dense(16, activation="relu")(x)

# Input 2: Geospatial & satellite data (CNN)
geo_input = Input(shape=(128, 128, 3))  # Example: 128x128 satellite image
y = Conv2D(32, (3, 3), activation="relu")(geo_input)
y = Flatten()(y)
geo_output = Dense(16, activation="relu")(y)

# Input 3: Sequential wildfire spread data (LSTM)
seq_input = Input(shape=(5, 3))  # Example: 5 time steps, 3 features
z = LSTM(32, return_sequences=True)(seq_input)
z = LSTM(16)(z)
seq_output = Dense(16, activation="relu")(z)

# Combine all inputs
combined = Concatenate()([num_output, geo_output, seq_output])
final_output = Dense(1, activation="sigmoid")(combined)  # Binary classification: Safe/Unsafe Route

# Build model
model = Model(inputs=[num_input, geo_input, seq_input], outputs=final_output)
model.compile(optimizer="adam", loss="binary_crossentropy", metrics=["accuracy"])
model.summary()

pip install tensorflow numpy opencv-python matplotlib

from tensorflow.keras.models import Model
from tensorflow.keras.layers import Input, Dense, LSTM, Conv2D, Flatten, Concatenate

# Rebuild Model (same as before)
num_input = Input(shape=(10,))
x = Dense(64, activation="relu")(num_input)
x = Dense(32, activation="relu")(x)
num_output = Dense(16, activation="relu")(x)

geo_input = Input(shape=(128, 128, 3))
y = Conv2D(32, (3, 3), activation="relu")(geo_input)
y = Flatten()(y)
geo_output = Dense(16, activation="relu")(y)

seq_input = Input(shape=(5, 3))
z = LSTM(32, return_sequences=True)(seq_input)
z = LSTM(16)(z)
seq_output = Dense(16, activation="relu")(z)

combined = Concatenate()([num_output, geo_output, seq_output])
final_output = Dense(1, activation="sigmoid")(combined)

model = Model(inputs=[num_input, geo_input, seq_input], outputs=final_output)
model.compile(optimizer="adam", loss="binary_crossentropy", metrics=["accuracy"])

sequence_data = np.array([[
    [3.5, 12.0, 35.1],
    [4.2, 13.5, 33.8],
    [4.8, 14.1, 32.0],
    [5.0, 15.2, 30.5],
    [5.5, 16.0, 29.8]
]])  # Shape: (1,5,3)

prediction = model.predict([numerical_data, image, sequence_data])
if prediction[0][0] > 0.5:
    print("🔥 Route is SAFE for evacuation.")
else:
    print("⚠️ Route is UNSAFE! Find an alternative.")

import csv
import math
import heapq
import ast

# Define a Node class to store information about the nodes
class Node:
    def __init__(self, name, parent=None, g=0, h=0):
        self.name = name  # Node name or position (latitude, longitude)
        self.parent = parent  # Parent node (used for path reconstruction)
        self.g = g  # Cost from start to this node
        self.h = h  # Heuristic cost from this node to goal
        self.f = g + h  # Total cost (f = g + h)

    def __lt__(self, other):
        return self.f < other.f  # For comparison in the priority queue

# Haversine formula to calculate distance between two coordinates
def haversine(lat1, lon1, lat2, lon2):
    R = 6371  # Earth radius in kilometers
    phi1, phi2 = math.radians(lat1), math.radians(lat2)
    delta_phi = math.radians(lat2 - lat1)
    delta_lambda = math.radians(lon2 - lon1)

    a = math.sin(delta_phi / 2) ** 2 + math.cos(phi1) * math.cos(phi2) * math.sin(delta_lambda / 2) ** 2
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))

    return R * c  # Return distance in kilometers

# Define the A* algorithm
def a_star(graph, start, goal, heuristic):
    open_list = []
    closed_list = set()

    start_node = Node(start, None, 0, heuristic(start, goal))
    heapq.heappush(open_list, start_node)

    while open_list:
        current_node = heapq.heappop(open_list)

        if current_node.name == goal:
            path = []
            while current_node:
                path.append(current_node.name)
                current_node = current_node.parent
            return path[::-1]  # Return reversed path

        closed_list.add(current_node.name)

        for neighbor in graph[current_node.name]:
            if neighbor in closed_list:
                continue

            g = current_node.g + haversine(current_node.name[0], current_node.name[1], neighbor[0], neighbor[1])
            h = heuristic(neighbor, goal)
            neighbor_node = Node(neighbor, current_node, g, h)

            if not any(open_node.name == neighbor and open_node.f <= neighbor_node.f for open_node in open_list):
                heapq.heappush(open_list, neighbor_node)

    return None  # If no path exists

# Heuristic function (Haversine distance)
def heuristic(node, goal):
    return haversine(node[0], node[1], goal[0], goal[1])

# Read shelters from CSV file
def read_shelters_from_csv(file_path):
    shelters = []
    with open(file_path, 'r') as file:
        reader = csv.DictReader(file)  # Use DictReader to access columns by name
        for row in reader:
            # Split the location into latitude and longitude
            name = row['name']
            address = row['address']

            location_dict = ast.literal_eval(row['location'])
            lat = location_dict['lat']
            lon = location_dict['lng']

            #print(lat)
            #print(lon)
            #lat, lon = map(float, row['location'].split(','))  # Split location by comma and convert to float
            shelters.append(((lat, lon), name, address))
    return shelters

# Main function to interact with user and run the A* algorithm
def main():
    # Path to the CSV file containing shelters (name, address, location)
    csv_file_path = 'shelters.csv'

    # Read shelters data from CSV
    shelters = read_shelters_from_csv(csv_file_path)

    # Get the user's starting point
    start_lat = float(input("Enter your latitude: "))
    start_lon = float(input("Enter your longitude: "))
    start = (start_lat, start_lon)

    # Find the nearest shelter by running A* from the start location to each shelter
    goal = min(shelters, key=lambda shelter: haversine(start[0], start[1], shelter[0][0], shelter[0][1]))[0]  # Nearest shelter

    # Build the graph (neighbors of each shelter)
    graph = {start: [shelter[0] for shelter in shelters]}  # Simple graph where the start is connected to all shelters

    # Run the A* algorithm to find the best path to the nearest shelter
    path = a_star(graph, start, goal, heuristic)

    if path:
        print("Path to the nearest shelter:", path)
    else:
        print("No path found!")

if __name__ == '__main__':
    main()

import requests
import csv
import heapq
import folium
import ast

# Google Routes API Key
ROUTES_API_KEY = "YOUR_GOOGLE_ROUTES_API_KEY"

# Air Quality API Key (Example: OpenWeatherMap)
AIR_QUALITY_API_KEY = "YOUR_AIR_QUALITY_API_KEY"

# Google Routes API Endpoint
ROUTES_API_URL = f"https://routes.googleapis.com/directions/v2:computeRoutes?key={ROUTES_API_KEY}"

# ✅ Get traffic-aware travel time using Routes API
def get_traffic_time(start, end):
    payload = {
        "origin": {"location": {"latLng": {"latitude": start[0], "longitude": start[1]}}},
        "destination": {"location": {"latLng": {"latitude": end[0], "longitude": end[1]}}},
        "travelMode": "DRIVE",
        "routingPreference": "TRAFFIC_AWARE"
    }

    headers = {
        "Content-Type": "application/json",
        "X-Goog-FieldMask": "routes.distanceMeters,routes.duration"
    }

    response = requests.post(ROUTES_API_URL, headers=headers, json=payload).json()

    if "routes" in response:
        return response["routes"][0]["duration"]  # Duration in seconds
    else:
        return float('inf')  # No route found, return high cost

# ✅ Get air quality data for a given location
def get_air_quality(lat, lng):
    url = f"http://api.openweathermap.org/data/2.5/air_pollution?lat={lat}&lon={lng}&appid={AIR_QUALITY_API_KEY}"
    response = requests.get(url).json()

    if response.get('list'):
        air_quality = response['list'][0]['main']['aqi']
        return air_quality  # 1: Good, 5: Very Poor
    else:
        return 5  # If no data, assume poor air quality

# ✅ Heuristic function considering traffic and air quality
def heuristic(current, goal):
    traffic_time = get_traffic_time(current, goal)
    air_quality_penalty = get_air_quality(goal[0], goal[1]) * 10  # Air quality penalty

    return traffic_time + air_quality_penalty

# ✅ A* Pathfinding Algorithm using Routes API
def astar(start, goal, graph):
    open_list = []
    heapq.heappush(open_list, (0, start))  # (f_cost, node)

    came_from = {}
    g_costs = {start: 0}
    f_costs = {start: heuristic(start, goal)}

    while open_list:
        _, current = heapq.heappop(open_list)

        if current == goal:
            path = []
            while current in came_from:
                path.append(current)
                current = came_from[current]
            path.append(start)
            path.reverse()
            return path

        for neighbor in graph[current]:
            tentative_g_cost = g_costs[current] + get_traffic_time(current, neighbor)
            if neighbor not in g_costs or tentative_g_cost < g_costs[neighbor]:
                g_costs[neighbor] = tentative_g_cost
                f_costs[neighbor] = tentative_g_cost + heuristic(neighbor, goal)
                heapq.heappush(open_list, (f_costs[neighbor], neighbor))
                came_from[neighbor] = current

    return None

# ✅ Read CSV file and extract locations
def read_shelter_csv(file_path):
    shelters = []
    with open(file_path, 'r') as file:
        reader = csv.reader(file)
        next(reader)  # Skip the header row
        for row in reader:
            name = row[0]
            address = row[1]
            location_dict = ast.literal_eval(row[2])
            lat = location_dict['lat']
            lng = location_dict['lng']
            shelters.append((name, (lat, lng)))
    return shelters

# ✅ Create a map and display the route
def visualize_route(path, shelter_dict):
    # Extract the first shelter’s coordinates for centering the map
    map_center = shelter_dict[path[0]]  # ✅ Now includes "USER_LOCATION"

    # Create a map
    m = folium.Map(location=map_center, zoom_start=12)

    # Add markers for shelters + user location
    for name, (lat, lng) in shelter_dict.items():
        folium.Marker([lat, lng], popup=name).add_to(m)

    # Convert path names to coordinates
    route_coords = [shelter_dict[name] for name in path]

    # Draw the optimal path
    folium.PolyLine(locations=route_coords, color="blue", weight=2.5, opacity=1).add_to(m)

    # Save map as HTML file
    m.save("optimal_route.html")


# ✅ Find the optimal escape route
def find_optimal_route(csv_file_path, origin_lat, origin_lng):
    shelters = read_shelter_csv(csv_file_path)

    # Convert shelters to a dictionary for easy lookup
    shelter_dict = {name: (lat, lng) for name, (lat, lng) in shelters}

    # Add the user’s origin location to the graph as "USER_LOCATION"
    shelter_dict["USER_LOCATION"] = (origin_lat, origin_lng)

    # Create a graph with distances between destinations
    graph = {name: [] for name in shelter_dict.keys()}  # Include USER_LOCATION

    for name1, loc1 in shelter_dict.items():
        for name2, loc2 in shelter_dict.items():
            if name1 != name2:
                graph[name1].append(name2)  # Store shelter names as neighbors

    # Set the origin and goal
    origin = "USER_LOCATION"  # ✅ Use name, not (lat, lng)
    goal = list(shelter_dict.keys())[1]  # ✅ Pick the first shelter as the goal

    # Run A* algorithm
    path = astar(origin, goal, graph)

    if path:
        visualize_route(path, shelter_dict)
        print(f"Optimal path found: {path}")
    else:
        print("No path found.")

# ✅ Get user input for starting location
def get_user_input():
    origin_lat = float(input("Enter the origin latitude: "))
    origin_lng = float(input("Enter the origin longitude: "))

    return origin_lat, origin_lng

# ✅ Run the program
csv_file_path = 'shelters.csv'
origin_lat, origin_lng = get_user_input()
find_optimal_route(csv_file_path, origin_lat, origin_lng)

from google.colab import drive
drive.mount('/content/drive')