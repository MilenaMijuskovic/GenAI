# -*- coding: utf-8 -*-
"""WildfireAccessibility.ipynb
Automatically generated by Colab.
Original file is located at
    https://colab.research.google.com/drive/1cbPA6laxQBM5cexPWxf4NjYfI6S1vf08
"""
import googlemaps
import folium
from googlemaps.convert import decode_polyline
import requests
import json
import networkx as nx
import matplotlib.pyplot as plt
import random  # For simulating accessibility data
import csv

def get_coordinates():
    try:
        origin_str = input()
        origin = eval(origin_str)
        destination_str = input()
        destination = eval(destination_str)
        if not (isinstance(origin, list) and len(origin) == 2 and
                isinstance(destination, list) and len(destination) == 2):
            raise ValueError("Invalid coordinate format. Must be [latitude, longitude].")
        return origin, destination
    except (ValueError, SyntaxError, NameError) as e:
        print(f"Error: {e}")
        return None, None

class routeManager: 
    def __init__(self):
        self.api_key = "AIzaSyDOasWCFyUrISMIqyy8w5jpPNgyUhk3yvM"
        self.routes_url = f"https://routes.googleapis.com/directions/v2:computeRoutes?key={self.api_key}"
    def generate_payload(self, origin, destination): 
        payload = {
            "origin": {
                "location": {
                    "latLng": {
                        "latitude": origin[0],
                        "longitude": origin[1]
                    }
                }
            },
            "destination": {
                "location": {
                    "latLng": {
                        "latitude": destination[0],
                        "longitude": destination[1]
                    }
                }
            },
            "travelMode": "DRIVE",
            "routingPreference": "TRAFFIC_AWARE"
        }
        return payload 
    
    def generate_html(self, origin, destination): 
        routes_api_url = f"https://routes.googleapis.com/directions/v2:computeRoutes?key={self.api_key}"
        headers = {
            "Content-Type": "application/json",
            "X-Goog-FieldMask": "routes.distanceMeters,routes.duration,routes.polyline.encodedPolyline"
        }
        payload = self.generate_payload(origin, destination)
        response = requests.post(routes_api_url, headers=headers, json=payload)
        if response.status_code == 200:
            data = response.json()
            print(json.dumps(data, indent=2))  # Nicely formatted JSON
            # Decode the polyline
            decoded_path = decode_polyline(data["routes"][0]["polyline"]["encodedPolyline"])
            # Extract coordinates
            coordinates = [(coord["lat"], coord["lng"]) for coord in decoded_path]
            # Create a Folium map centered on the first coordinate
            map_center = coordinates[0]
            m = folium.Map(location=map_center, zoom_start=12)
            # Add the polyline to the map
            folium.PolyLine(locations=coordinates, color="blue").add_to(m)
            # Display the map
            m.save("route_map.html") #saves the map to a html file that can be opened in a browser.
            return m 
        else:
            print(f"Error: {response.status_code}")
            print(response.text)

if __name__ == "__main__":
    rm = routeManager()
    origin = [40.7335062, -74.17646599999999]
    destination =  [40.7585922, -73.9955514]
    rm.generate_html(origin, destination)

# # 1. Simplified Wildfire Data
# # Example road network (nodes and edges)
# edges = [
#     ("A", "B", {"distance": 10, "fire_distance": 5}),  # (node1, node2, {attributes})
#     ("B", "C", {"distance": 15, "fire_distance": 10}),
#     ("C", "D", {"distance": 5, "fire_distance": 2}),
#     ("A", "D", {"distance": 20, "fire_distance": 8}),
#     ("B", "D", {"distance": 7, "fire_distance": 15}),
# ]

# fire_perimeter_nodes = ["C"]  # Nodes within or close to the fire perimeter

# # 2. Network Graph
# G = nx.Graph()
# G.add_edges_from([(u, v, data) for u, v, data in edges])

# # 3. Cost Function (Distance + Fire Proximity)
# def cost_function(u, v, data):
#     distance_weight = 1.0  # Adjust these weights to change the importance of these parameters.
#     fire_distance_weight = 2.0
#     return data["distance"] * distance_weight + (20 - data["fire_distance"]) * fire_distance_weight # 20 is just a number to make the fire distance a higher cost when closer.

# # 4. Shortest Path Calculation (using custom cost function)
# start_node = "A"
# end_node = "D"
# shortest_path = nx.shortest_path(G, source=start_node, target=end_node, weight=cost_function)

# # 5. Visualization
# pos = nx.spring_layout(G)
# nx.draw(G, pos, with_labels=True)
# edge_labels = nx.get_edge_attributes(G, "distance")
# nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)
# nx.draw_networkx_nodes(G, pos, nodelist=fire_perimeter_nodes, node_color="red")
# nx.draw_networkx_nodes(G, pos, nodelist=shortest_path, node_color="green")
# plt.show()


# # --- 1. Road Network and Wildfire Data ---
# edges = [
#     ("A", "B", {"distance": 10, "fire_distance": 5}),
#     ("B", "C", {"distance": 15, "fire_distance": 10}),
#     ("C", "D", {"distance": 5, "fire_distance": 2}),
#     ("A", "D", {"distance": 20, "fire_distance": 8}),
#     ("B", "D", {"distance": 7, "fire_distance": 15}),
# ]

# fire_perimeter_nodes = ["C"]

# # --- 2. Simulated Accessibility Data ---
# # Assume each edge has an accessibility score (0: inaccessible, 1: fully accessible)
# accessibility_data = {
#     ("A", "B"): 0.8,  # 80% accessible
#     ("B", "C"): 0.2,  # 20% accessible (e.g., stairs)
#     ("C", "D"): 0.9,  # 90% accessible
#     ("A", "D"): 0.7,  # 70% accessible
#     ("B", "D"): 0.6,  # 60% accessible
# }

# # --- 3. Network Graph ---
# G = nx.Graph()
# G.add_edges_from([(u, v, data) for u, v, data in edges])

# # --- 4. Enhanced Cost Function ---
# def cost_function(u, v, data):
#     distance_weight = 1.0  # Weight for distance
#     fire_distance_weight = 2.0  # Weight for fire proximity
#     accessibility_weight = 3.0  # Weight for accessibility
#     # Fire proximity cost (higher cost when closer to fire)
#     fire_cost = (20 - data["fire_distance"]) * fire_distance_weight
#     # Accessibility cost (higher cost for less accessible routes)
#     accessibility_cost = (1 - accessibility_data.get((u, v), 0.5)) * accessibility_weight
#     # Total cost
#     total_cost = (
#         data["distance"] * distance_weight +
#         fire_cost +
#         accessibility_cost
#     )
#     return total_cost

# # --- 5. Shortest Path Calculation ---
# start_node = "A"
# end_node = "D"
# shortest_path = nx.shortest_path(G, source=start_node, target=end_node, weight=lambda u, v, d: cost_function(u, v, d))

# # --- 6. Visualization ---
# pos = nx.spring_layout(G)
# nx.draw(G, pos, with_labels=True, node_size=700, node_color="skyblue", font_size=10, font_weight="bold")
# edge_labels = nx.get_edge_attributes(G, "distance")
# nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color="red")

# # Highlight fire perimeter nodes
# nx.draw_networkx_nodes(G, pos, nodelist=fire_perimeter_nodes, node_color="red", node_size=800)

# # Highlight shortest path nodes
# path_edges = list(zip(shortest_path, shortest_path[1:]))
# nx.draw_networkx_edges(G, pos, edgelist=path_edges, edge_color="green", width=2)
# nx.draw_networkx_nodes(G, pos, nodelist=shortest_path, node_color="green", node_size=800)

# plt.title("Accessible Escape Route During Wildfire")
# plt.show()



# def get_closest_shelters(lat, lng, radius=50000, max_shelters=25):
#     gmaps = googlemaps.Client(key='AIzaSyDOasWCFyUrISMIqyy8w5jpPNgyUhk3yvM')

#     # Search for nearby shelters
#     places_result = gmaps.places_nearby(
#         location=(lat, lng),
#         radius=radius,
#         keyword="emergency shelter"
#     )

#     shelters = places_result.get("results", [])

#     return [
#         {
#             "name": shelter["name"],
#             "address": shelter.get("vicinity", "N/A"),
#             "location": shelter["geometry"]["location"]
#         }
#         for shelter in shelters
#     ]

# def get_accessible_shelters(lat, lng, radius=50000, max_shelters=25):
#     gmaps = googlemaps.Client(key='AIzaSyDOasWCFyUrISMIqyy8w5jpPNgyUhk3yvM')


#     accessible_words = {'access', 'ramp', 'wheelchair', 'elevator', 'accessible', 'disability', 'disabled', 'handicap', 'handicapped', 'mobility', 'impairment', 'impairments', 'disabilities', 'disability'}
#     non_accessible_words = {'no access', 'stairs', 'no elevator', 'no ramp', 'icy', 'steep', 'obstacles', 'no wheelchair'}

#     # Search for nearby shelters
#     places_result = gmaps.places_nearby(
#         location=(lat, lng),
#         radius=radius,
#         keyword="emergency shelter"
#     )

#     shelters = places_result.get("results", [])
#     accessible_shelters = []

#     for shelter in shelters:
#         place_details = gmaps.place(
#             place_id=shelter["place_id"],
#             fields=["name", "vicinity", "geometry", "wheelchair_accessible_entrance"]
#         )
#         wheelchair_accessible = place_details.get("result", {}).get("wheelchair_accessible_entrance", False)

#         if wheelchair_accessible:
#             accessible_shelters.append(shelter)

#     return [
#         {
#             "name": shelter["name"],
#             "address": shelter.get("vicinity", "N/A"),
#             "location": shelter["geometry"]["location"]
#         }
#         for shelter in accessible_shelters
#     ]

# def save_shelters_to_csv(shelters, filename="shelters.csv"):
#     with open(filename, mode="w", newline="", encoding="utf-8") as file:
#         writer = csv.DictWriter(file, fieldnames=["name", "address", "location"])
#         writer.writeheader()
#         writer.writerows(shelters)

# if __name__ == "__main__":
#     current_lat = 40.7128  # Example latitude (New York City)
#     current_long = -74.0060  # Example longitude (New York City)
#     closest_shelters = get_closest_shelters(current_lat, current_long)
#     closest_accessible_shelters = get_accessible_shelters(current_lat, current_long)
#     save_shelters_to_csv(closest_shelters)
#     save_shelters_to_csv(closest_accessible_shelters, filename="accessible_shelters.csv")

# origin = f"{latitude},{longitude}"
# directions_url = f"https://maps.googleapis.com/maps/api/directions/json?origin={origin}&destination={destination}&mode=driving&key={api_key}"

# for place in data["results"]:
#   response = requests.get(directions_url)
#   directions_data = response.json()
#   if directions_data["routes"]:
#     print(place["name"], "-" ,"Safe Route Available")
#   else:
#     print(place["name"], "-" ,"No Safe Route Found")


# # Create map
# m = folium.Map(location=[latitude, longitude], zoom_start=10)

# # Add evacuation sites to map
# for place in data["results"]:
#     folium.Marker(
#         location=[place["geometry"]["location"]["lat"], place["geometry"]["location"]["lng"]],
#         popup=place["name"],
#         icon=folium.Icon(color="green"),
#     ).add_to(m)

# # Save map
# m.save("evacuation_map.html")
# fire_url = "https://firms.modaps.eosdis.nasa.gov/api/area/csv/YOUR_NASA_API_KEY/VIIRS_SNPP_NRT/USA/1"
# fire_data = requests.get(fire_url).text
# print(fire_data)

# #... get_route and create_map functions from above.
# def main():
#     origin = input("Enter origin address or coordinates: ")
#     destination = input("Enter destination address or coordinates: ")
#     api_key = input("Enter your Google Maps API key: ")
#     route_coordinates = get_route(origin, destination, api_key)
#     create_map(route_coordinates)
# if __name__ == "__main__":
#     main()